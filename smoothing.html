<html>
<head>
  <title>Gaussian Smoothing</title>
  <link rel="stylesheet" href="./d3.slider.css" />
    <style type="text/css">
    body{
        font-family: sans-serif;
    }
    svg{
        //border: 1px solid #eee;
    }
    .wrapper {
      width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    .chart-line{
        fill:none;
        stroke-width:1px;
    }

    .raw{
        stroke:#aaa;
    }

    .smoothed{
        stroke:#93f;
    }

    .axis path {
      display: none;
    }

    .axis line {
      shape-rendering: crispEdges;
      stroke: #777;
      stroke-dasharray: 1,5;
    }

    .axis .minor line {
      stroke: #eee;
      stroke-dasharray: 2,2;
    }
    .brush .extent {
        stroke: #000;
        fill-opacity: .125;
        shape-rendering: crispEdges;
    }
    </style>
</head>
<body>
<h1>Gaussian Filter - an attempt to learn JS and d3. Originally from: <a href="http://bl.ocks.org/tomgp/6770520"/a>tomgp</a></h1>

<div class="wrapper">
<h2>Noise</h2><div id="sliderNoise"></div>
<h2>Complexity</h2><div id="sliderComplex"></div></div>
<div id='chart'></div>
<div class='key'>
</div>
</body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript" src="./d3.slider.js"></script>
<script src="./underscore.js" type="text/javascript"></script>
<script type="text/javascript">

//<script src="http://d3js.org/d3.v3.min.js">

var margin = {
    left:50,
    right:30,
    top:30,
    bottom:30
}

var width = 700;
var height = 500;
var centering = false;
var center;
var alpha = 0.2;
var kernel_size = 5;
var max_kernel = 25;
var sigma = (kernel_size-1)/2;
var kx = _.range(-sigma, sigma+1, 1);
var ky = kx.map(gauss);
var kernel = normaliseKernel(ky);

var ranX = _.range(0, 140, 1);
var raw = ranX;
var noise = 0.1;
var complex = 0.01;

generateData(noise, complex);
var smoothed = convolute(raw, kernel);

function getMaxOfArray(numArray) {
  return Math.max.apply(null, numArray);
}

function generateData(noise, complex){
    ranX = _.range(0, 140, 1);
    raw = ranX;

    for (var i=0; i<raw.length; i++){
        raw[i] += Math.abs(Math.sin(ranX[i]*complex)*Math.pow(ranX[i], 2));
    }

    var yMax = getMaxOfArray(raw);
    for (var i=0; i<raw.length; i++){
        raw[i] /= yMax;
        raw[i] -= 0.4;
        raw[i] += Math.random()*noise;
    }
    smoothed = convolute(raw, kernel);
}

d3.select('#sliderNoise').call(d3.slider().min(0).max(1).step(0.01).value(noise).on("slide", function(evt, value) {
    noise = value;
    generateData(noise, complex);
    svg.selectAll("path")
      .data([raw]) // set the new data
      .attr("d", line); // apply the new data values
}));

d3.select('#sliderComplex').call(d3.slider().min(0.01).max(0.2).step(0.01).value(complex).on("slide", function(evt, value) {
    complex = value;
    generateData(noise, complex);
    svg.selectAll("path")
      .data([raw]) // set the new data
      .attr("d", line); // apply the new data values
}));

var dataset = [[0, d3.extent(raw)[0], kernel_size, d3.extent(raw)[1]-d3.extent(raw)[0]]];

var yScale = d3.scale.linear()
    .domain( d3.extent( raw ) )
    .range( [height-margin.top, margin.bottom] );

var xScale = d3.scale.linear()
    .domain( [0, raw.length] )
    .range( [margin.left, width-margin.right] );

var xScaleBG = d3.scale.linear()
    .domain( [-(max_kernel-1)/2, raw.length+(max_kernel-1)/2] )
    .range( [margin.left-xScale(-(max_kernel-1)/2), width-margin.right+xScale((max_kernel-1)/2)] );

var line = d3.svg.line()
    .x(function(d,i) { return xScale(i); })
    .y(function(d,i) { return yScale(d); });

var svg = d3.select('#chart')
            .append('svg')
            .attr('height', height)
            .attr('width', width)
            .append('g')

var dx = width/raw.length;

var bg = svg.append('rect')
            .attr("height", height)
            .attr("width", 0)
            .attr("x", 0)
            .attr("y", 0)
            .attr("opacity", 0.1)

svg.selectAll('path.line')
    .data([raw])
    .enter()
    .append("svg:path")
    .attr("class", "chart-line raw")
    .attr("d", line);

var smoothPath = svg.append('path')
                    .datum(smoothed.slice(0, 0))
                    .attr("class", "chart-line smoothed")
                    .attr("d", line)
                    .attr("ID", "smooth");

var brush = d3.svg.brush()
    .x(xScale)
    .extent([0, 6])
    .on("brush", brushed);

var gBrush = svg.append("g")
    .attr("class", "brush")
    .call(brush);

var tabs = gBrush.selectAll(".resize").append("rect")
                 .attr("transform", "translate(-2.5, 0)")
                 .attr("height", height)
                 .attr("width", 5)
                 .attr("x", 0)
                 .attr("y", 0)
                 .attr("fill", "red")
                 .attr("opacity", 0.1);

gBrush.selectAll("rect")
    .attr("height", height);

function update_smooth(extent){
    d3.selectAll("path")[0][1]
      .remove();
    svg.append('path')
       .datum(smoothed.slice(0, Math.max(0,Math.round(extent[1]))))
       .attr("class", "chart-line smoothed")
       .attr("d", line)
       .attr("ID", "smooth");
    if (extent[0] > 0){
        bg.attr("width", xScale(extent[1]));
    }
    else {
        bg.attr("width", 0);
    }
}

function brushed() {
  var extent0 = brush.extent(),
      extent1;

  // if dragging, preserve the width of the extent
  if (d3.event.mode === "move") {
    var d0 = Math.round(extent0[0]),
        d1 = (d0 + Math.round(extent0[1] - extent0[0]));
    extent1 = [d0, d1];
    center = d0+(d1-d0)/2;

  }

  // otherwise, if resizing, round both values
  else {
        if ((extent0[0] <= 0) &&
            (extent0[1] - extent0[0] < raw.length/2) &&
            (extent0[1] - extent0[0] > 3)) {
            extent1 = extent0.map(Math.round);
            if (extent1[1]-extent1[0]%2 != 0){
                extent1[1] += 1;
            }

            // if empty when rounded, use floor & ceil instead
            if (extent1[0] >= extent1[1]) {
              extent1[0] = Math.floor(extent0[0]);
              extent1[1] = Math.ceil(extent0[1]);
            }

            kernel_size = extent1[1]-extent1[0];
            sigma = (kernel_size-1)/2;
            kx = _.range(-sigma, sigma+1, 1);
            ky = kx.map(gauss);
            kernel = normaliseKernel(ky);
            smoothed = convolute(raw, kernel);
        }
        else {
            extent1 = [extent0[0], extent0[0]+kernel.length];
            tabs.attr('width', 0);
        }
  }
  if (extent1[0] > 0){
    document.getElementById("sliderNoise").style.pointerEvents = "none";
    document.getElementById("sliderComplex").style.pointerEvents = "none";
    tabs.attr('width', 0);
  }
  else {
    tabs.attr('width', 5);
    document.getElementById("sliderNoise").style.pointerEvents = "auto";
    document.getElementById("sliderComplex").style.pointerEvents = "auto";
  }
  update_smooth(extent1);
  d3.select(this).call(brush.extent(extent1));
}


gBrush.select(".background")
    .on("mousedown.brush", brushcenter)
    .on("touchstart.brush", brushcenter);

gBrush.call(brush.event);

function brushmove() {
  var extent = brush.extent();
  dot.classed("selected", function(d) { return extent[0] <= d && d <= extent[1]; });
}

function brushcenter() {
  var self = d3.select(window),
      target = d3.event.target,
      extent = brush.extent(),
      size = extent[1] - extent[0],
      domain = xScale.domain(),
      x0 = domain[0] + size / 2,
      x1 = domain[1] - size / 2;

  recenter(true);
  brushmove();

  if (d3.event.changedTouches) {
    self.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
  } else {
    self.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
  }

  function brushmove() {
    d3.event.stopPropagation();
    center = Math.max(x0, Math.min(x1, xScale.invert(d3.mouse(target)[0])));
    recenter(false);
    update_smooth(extent);
    if (extent[0] > 0){
      document.getElementById("sliderNoise").style.pointerEvents = "none";
      document.getElementById("sliderComplex").style.pointerEvents = "none";
      tabs.attr('width', 0);
    }
    else {
        document.getElementById("sliderNoise").style.pointerEvents = "auto";
        document.getElementById("sliderComplex").style.pointerEvents = "auto";
    }
  }

  function brushend() {
    brushmove();
    self.on(".brush", null);
  }
}

function recenter(smooth) {
  if (centering) return; // timer is active and already tweening
  if (!smooth) return void tween(1); // instantaneous jump
  centering = true;

  function tween(alpha) {
    var extent = brush.extent(),
        size = extent[1] - extent[0],
        center1 = center * alpha + (extent[0] + extent[1]) / 2 * (1 - alpha);

    gBrush
        .call(brush.extent([center1 - size / 2, center1 + size / 2]))
        .call(brush.event);

    return !(centering = Math.abs(center1 - center) > 1e-3);
  }

  d3.timer(function() {
    return tween(alpha);
  });
}

var ticks = d3.extent( raw );
ticks.push(0)
ticks = ticks.sort();

var yAxis = d3.svg.axis()
    .scale(yScale)
    .tickSize(width - (margin.left+margin.right))
    .tickValues( ticks )
    .orient("right");

var xAxis = d3.svg.axis()
    .scale(xScale)
    .tickSize(6, 0)
    .orient("bottom");

svg.append("g")
    .attr("class", "y axis")
    .attr("transform", "translate("+margin.left+",0)")
    .call(yAxis);

svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0,"+(height-margin.top)+")")
    .call(xAxis);

function gauss(x){
    return 1/(Math.sqrt(2*Math.PI)*sigma)*Math.exp(-Math.pow(x, 2)/(2*Math.pow(sigma, 2)));
}

function convolute(data, kernel, accessor){
    var kernel_center = Math.floor(kernel.length/2);
    var left_size = kernel_center;
    var right_size = kernel.length - (kernel_center-1);
    if(accessor == undefined){
        accessor = function(datum){
            return datum;
        }
    }

    function constrain(i,range){
        if(i<range[0]){
            i=0;
        }
        if(i>range[1]){
            i=range[1];
        }
        return i;
    }

    var convoluted_data = data.map(function(d,i){
        var s = 0;
        for(var k=0; k < kernel.length; k++){
            var index = constrain( ( i + (k-kernel_center) ), [0, data.length-1] );
            s += kernel[k] * accessor(data[index]);
        }
        return s;
    });


    return convoluted_data;
}

function normaliseKernel(a){
    function arraySum(a){
        var s = 0;
        for (var i =0;i<a.length;i++){
            s += a[i];
        }
        return s;
    }

    var sum_a = arraySum(a);
    var scale_factor = sum_a / 1;
    a = a.map(function(d){
        return d / scale_factor;
    })
    return a;
}

</script>
</html>